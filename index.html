<!doctype html>
<html lang="en" data-theme="system">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="color-scheme" content="light dark" />
  <title>Manga Reader</title>

  <!-- ===================== STYLES ===================== -->
  <style>
    :root {
      --bg: #0b0d12;
      --bg-soft: #10141c;
      --panel: #151b24;
      --text: #ecf2ff;
      --muted: #9bb0c9;
      --accent: #6aa9ff;
      --accent-2: #9b7bff;
      --border: #263043;

      /* Light mode tokens */
      --bg-light: #f7f9fc;
      --bg-soft-light: #ffffff;
      --panel-light: #ffffff;
      --text-light: #0c1220;
      --muted-light: #5c667a;
      --border-light: #d8e0ee;
      --accent-light: #2f6bff;
      --accent-2-light: #7b5cff;

      --toolbar-h: 56px;
      --thumb-w: 72px;
      --radius: 12px;

      --transition-fast: 150ms ease;
      --transition: 250ms ease;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }

    /* Theme application */
    html[data-theme="dark"] {
      --bg: var(--bg);
      --bg-soft: var(--bg-soft);
      --panel: var(--panel);
      --text: var(--text);
      --muted: var(--muted);
      --border: var(--border);
      --accent: var(--accent);
      --accent-2: var(--accent-2);
    }
    html[data-theme="light"] {
      --bg: var(--bg-light);
      --bg-soft: var(--bg-soft-light);
      --panel: var(--panel-light);
      --text: var(--text-light);
      --muted: var(--muted-light);
      --border: var(--border-light);
      --accent: var(--accent-light);
      --accent-2: var(--accent-2-light);
    }
    html[data-theme="system"] { color-scheme: light dark; }
    @media (prefers-color-scheme: light) {
      html[data-theme="system"] {
        --bg: var(--bg-light);
        --bg-soft: var(--bg-soft-light);
        --panel: var(--panel-light);
        --text: var(--text-light);
        --muted: var(--muted-light);
        --border: var(--border-light);
        --accent: var(--accent-light);
        --accent-2: var(--accent-2-light);
      }
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
    }

    /* ===================== LAYOUT ===================== */
    .reader {
      position: relative;
      height: 100dvh;
      width: 100%;
      display: grid;
      grid-template-rows: calc(var(--toolbar-h) + var(--safe-top)) 1fr;
      overflow: hidden;
      background: var(--bg);
    }

    /* ===================== TOOLBAR ===================== */
    .toolbar {
      display: flex;
      align-items: center;
      gap: .5rem;
      padding: calc(var(--safe-top)) .5rem 0 .5rem;
      background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,0)), var(--bg-soft);
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      z-index: 20;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      height: calc(var(--toolbar-h) + var(--safe-top));
      box-sizing: border-box;
    }
    .tool-left, .tool-right { display: inline-flex; align-items: center; gap: .5rem; }
    .toolbar .title {
      font-weight: 600; letter-spacing: .3px; margin: 0 .25rem; color: var(--muted);
      white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
    }
    .spacer { flex: 1; }
    .btn {
      display: inline-flex; align-items: center; justify-content: center; gap: .35rem;
      height: 36px; padding: 0 .75rem;
      background: var(--panel);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 9px;
      cursor: pointer;
      transition: transform var(--transition-fast), background var(--transition-fast), border-color var(--transition-fast), opacity var(--transition-fast);
      user-select: none;
    }
    .btn:hover { transform: translateY(-1px); }
    .btn:active { transform: translateY(0); }
    .btn[aria-pressed="true"], .btn.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px color-mix(in oklab, var(--accent) 60%, transparent);
    }
    .btn.icon { width: 36px; padding: 0; }
    .seg { display: inline-flex; background: var(--panel); border: 1px solid var(--border); border-radius: 9px; overflow: hidden; }
    .seg .btn { border: none; border-right: 1px solid var(--border); }
    .seg .btn:last-child { border-right: none; }

    /* ===================== STAGE ===================== */
    .stage { position: relative; overflow: hidden; background: var(--bg); }

    /* Paged */
    .page-wrap {
      height: 100%; width: 100%;
      display: grid; place-items: center;
      overflow: hidden; position: relative;
      touch-action: pan-y pinch-zoom; /* system pinch-to-zoom */
      user-select: none;
    }
    .page {
      max-width: 100%; max-height: 100%;
      object-fit: contain;
      transform-origin: center center;
      will-change: transform;
      image-rendering: auto;
      user-select: none;
      -webkit-user-drag: none;
      pointer-events: none; /* image doesn’t capture clicks (we pan on wrapper) */
    }

    /* Vertical / webtoon */
    .webtoon {
      position: absolute; inset: 0;
      overflow: auto; overscroll-behavior: contain;
      padding: 16px 0 calc(80px + var(--safe-bottom));
      scroll-behavior: smooth;
      touch-action: pan-y; /* natural scrolling */
    }
    .webtoon::-webkit-scrollbar { width: 10px; }
    .webtoon::-webkit-scrollbar-thumb { background: var(--border); border-radius: 999px; }
    .strip {
      width: min(1200px, 100%);
      margin: 0 auto;
      display: flex; flex-direction: column; gap: 12px;
      padding: 0 8px;
      box-sizing: border-box;
    }
    .strip img {
      width: 100%; height: auto; display: block;
      border-radius: var(--radius);
      background: var(--panel);
      border: 1px solid var(--border);
      -webkit-user-drag: none;
    }

    /* Thumbnails */
    .thumbs {
      position: absolute; bottom: calc(10px + var(--safe-bottom)); left: 50%; transform: translateX(-50%);
      background: color-mix(in oklab, var(--panel) 90%, transparent);
      border: 1px solid var(--border); border-radius: 12px;
      padding: 6px; display: flex; gap: 6px; align-items: center;
      max-width: min(95vw, 1200px); overflow: auto; backdrop-filter: blur(6px);
    }
    .thumb { width: var(--thumb-w); height: calc(var(--thumb-w) * 1.4); background: var(--panel); border: 1px solid var(--border); border-radius: 8px; overflow: hidden; flex: 0 0 auto; cursor: pointer; opacity: .8; }
    .thumb.active { outline: 2px solid var(--accent); opacity: 1; }
    .thumb img { width: 100%; height: 100%; object-fit: cover; display: block; }

    /* Auto-hide toolbar while reading */
    .auto-hide .toolbar {
      opacity: 0; pointer-events: none; transform: translateY(-10px);
      transition: opacity var(--transition), transform var(--transition);
    }
    .show-ui .toolbar { opacity: 1; pointer-events: auto; transform: translateY(0); }

    /* Small screens */
    @media (max-width: 640px) {
      .btn span.label { display: none; }
      .title { display: none; }
    }

    /* Hidden source bucket (paste your existing images here) */
    #source-images { display: none; }
  </style>
</head>
<body>

  <!-- ========= Keep your image paths exactly as they are (NO path changes) =========
       Paste your existing <img> tags here. The reader will use these sources directly.
       Example (replace with your real files and folders, keep the same names/paths):
       <img src="manga/001.jpg" alt02.jpg
       manga/003.jpg
  -->
  <div id="source-images">
    <!-- YOUR IMAGES GO HERE -->
    <!-- images/001.jpg -->
  </div>

  <div class="reader show-ui auto-hide" id="reader" aria-live="polite">
    <!-- ============== Toolbar ============== -->
    <div class="toolbar" role="toolbar" aria-label="Reader toolbar">
      <div class="tool-left">
        <button class="btn icon" id="btnPrev" title="Prev [← / A]">
          ◀
        </button>
        <button class="btn icon" id="btnNext" title="Next [→ / D]">
          ▶
        </button>

        <div class="seg" role="group" aria-label="Reading mode">
          <button class="btn" id="modePaged"><span class="label">Paged</span></button>
          <button class="btn" id="modeVertical"><span class="label">Vertical</span></button>
        </div>

        <div class="seg" role="group" aria-label="Direction">
          <button class="btn" id="dirLTR"><span class="label">LTR</span></button>
          <button class="btn" id="dirRTL"><span class="label">RTL</span></button>
        </div>
      </div>

      <div class="spacer"></div>
      <div class="title">Manga Reader</div>
      <div class="spacer"></div>

      <div class="tool-right">
        <div class="seg" role="group" aria-label="Fit mode">
          <button class="btn" id="fitWidth"><span class="label">Fit‑W</span></button>
          <button class="btn" id="fitHeight"><span class="label">Fit‑H</span></button>
          <button class="btn" id="fitOriginal"><span class="label">1:1</span></button>
        </div>

        <div class="seg" role="group" aria-label="Zoom">
          <button class="btn icon" id="zoomOut" title="Zoom out [−]">−</button>
          <button class="btn icon" id="zoomReset" title="Reset [0]">⟳</button>
          <button class="btn icon" id="zoomIn"  title="Zoom in [+]">+</button>
        </div>

        <div class="seg" role="group" aria-label="Theme">
          <button class="btn" id="themeLight"><span class="label">Light</span></button>
          <button class="btn" id="themeSystem"><span class="label">Auto</span></button>
          <button class="btn" id="themeDark"><span class="label">Dark</span></button>
        </div>

        <button class="btn icon" id="btnFS" title="Fullscreen [F]" aria-label="Toggle Fullscreen">⤢</button>
      </div>
    </div>

    <!-- ============== Stage ============== -->
    <div class="stage" id="stage">
      <!-- Paged view -->
      <div class="page-wrap" id="pageWrap" aria-label="Paged view" hidden>
        <img id="page" class="page" alt="page" />
      </div>

      <!-- Vertical long scroll -->
      <div class="webtoon" id="webtoon" aria-label="Vertical long scroll" hidden>
        <div class="strip" id="strip"></div>
      </div>

      <!-- Thumbnails -->
      <div class="thumbs" id="thumbs" role="listbox" aria-label="Pages"></div>
    </div>
  </div>

  <!-- ===================== SCRIPT ===================== -->
  <script>
    (function () {
      const $  = (sel, root=document) => root.querySelector(sel);
      const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

      const el = {
        reader:   $('#reader'),
        pageWrap: $('#pageWrap'),
        page:     $('#page'),
        webtoon:  $('#webtoon'),
        strip:    $('#strip'),
        thumbs:   $('#thumbs'),
        srcBucket: $('#source-images'),

        btnPrev: $('#btnPrev'),
        btnNext: $('#btnNext'),
        modePaged: $('#modePaged'),
        modeVertical: $('#modeVertical'),
        dirLTR: $('#dirLTR'),
        dirRTL: $('#dirRTL'),
        fitWidth: $('#fitWidth'),
        fitHeight: $('#fitHeight'),
        fitOriginal: $('#fitOriginal'),
        zoomIn: $('#zoomIn'),
        zoomOut: $('#zoomOut'),
        zoomReset: $('#zoomReset'),
        themeLight: $('#themeLight'),
        themeSystem: $('#themeSystem'),
        themeDark: $('#themeDark'),
        btnFS: $('#btnFS'),
        stage: $('#stage'),
      };

      // ===== Load images from your existing DOM (paths unchanged) =====
      const IMAGES = $$('#source-images img').map(img => ({
        src: img.getAttribute('src'),
        alt: img.getAttribute('alt') || '',
      }));

      if (!IMAGES.length) {
        console.warn('No images found. Put your <img> tags inside #source-images with original paths.');
      }

      // ===== State =====
      const S = {
        mode: localStorage.getItem('mode') || 'vertical', // 'paged' | 'vertical'
        dir: localStorage.getItem('dir') || 'rtl',        // 'ltr' | 'rtl'
        theme: localStorage.getItem('theme') || 'system', // 'light' | 'dark' | 'system'
        fit: localStorage.getItem('fit') || 'width',      // 'width' | 'height' | 'original'
        pageIndex: 0,
        scale: 1,
        minScale: 0.5,
        maxScale: 4,
        uiTimer: null,
        panX: 0,
        panY: 0,
        dragging: false,
        dragStart: { x: 0, y: 0, panX: 0, panY: 0 },
      };

      // ===== Theme =====
      function applyTheme(t = S.theme) {
        document.documentElement.setAttribute('data-theme', t);
        S.theme = t; localStorage.setItem('theme', t);
        [el.themeLight, el.themeSystem, el.themeDark].forEach(b => b.classList.remove('active'));
        ({light: el.themeLight, system: el.themeSystem, dark: el.themeDark}[t]).classList.add('active');
      }

      // ===== Thumbnails =====
      function buildThumbs() {
        el.thumbs.innerHTML = '';
        IMAGES.forEach((it, i) => {
          const t = document.createElement('button');
          t.className = 'thumb';
          t.setAttribute('role', 'option');
          t.setAttribute('aria-label', `Page ${i+1}`);
          t.addEventListener('click', () => goTo(i));
          const img = document.createElement('img');
          img.loading = 'lazy'; img.decoding = 'async';
          img.src = it.src; img.alt = it.alt || `Page ${i+1}`;
          t.appendChild(img);
          el.thumbs.appendChild(t);
        });
      }
      function markActiveThumb(i) {
        $$('.thumb', el.thumbs).forEach((t, idx) => t.classList.toggle('active', idx === i));
      }

      // ===== Vertical strip =====
      function buildStrip() {
        el.strip.innerHTML = '';
        IMAGES.forEach((it, i) => {
          const img = document.createElement('img');
          img.loading = 'lazy'; img.decoding = 'async';
          img.src = it.src; img.alt = it.alt || `Page ${i+1}`;
          img.setAttribute('data-idx', i);
          el.strip.appendChild(img);
        });

        // Observe to update active thumb while scrolling
        const io = new IntersectionObserver((entries) => {
          entries.forEach(e => {
            if (e.isIntersecting && e.intersectionRatio > 0.55) {
              const idx = +e.target.getAttribute('data-idx');
              S.pageIndex = idx; markActiveThumb(idx);
            }
          });
        }, { root: el.webtoon, threshold: [0.55] });

        $$('#strip img', el.webtoon).forEach(img => io.observe(img));
      }

      // ===== Paged helpers =====
      function showPage(i) {
        const idx = clamp(i, 0, IMAGES.length - 1);
        if (!IMAGES[idx]) return;
        el.page.src = IMAGES[idx].src;
        el.page.alt = IMAGES[idx].alt || `Page ${idx+1}`;
        S.pageIndex = idx;
        S.panX = 0; S.panY = 0; // reset pan when page changes
        markActiveThumb(idx);

        // Ensure transform recomputes after image loads
        if (!el.page.complete) {
          el.page.onload = () => { transformPage(); el.page.onload = null; };
        } else {
          transformPage();
        }
      }

      function clamp(v, a, b){ return Math.min(Math.max(v, a), b); }

      // Direction-aware nav
      function next() {
        if (S.mode === 'vertical') {
          el.webtoon.scrollBy({ top: el.webtoon.clientHeight * 0.9, behavior: 'smooth' });
          return;
        }
        const step = (S.dir === 'rtl') ? -1 : 1;
        goTo(S.pageIndex + step);
      }
      function prev() {
        if (S.mode === 'vertical') {
          el.webtoon.scrollBy({ top: -el.webtoon.clientHeight * 0.9, behavior: 'smooth' });
          return;
        }
        const step = (S.dir === 'rtl') ? 1 : -1;
        goTo(S.pageIndex + step);
      }
      function goTo(i) {
        i = clamp(i, 0, IMAGES.length - 1);
        if (S.mode === 'vertical') {
          const target = document.querySelector(`#strip img[data-idx="${i}"]`);
          if (target) target.scrollIntoView({ behavior: 'smooth', block: 'center' });
          S.pageIndex = i; markActiveThumb(i);
        } else {
          showPage(i);
        }
      }

      // ===== Fit & Zoom =====
      function applyFit() {
        [el.fitWidth, el.fitHeight, el.fitOriginal].forEach(b => b.classList.remove('active'));
        ({ width: el.fitWidth, height: el.fitHeight, original: el.fitOriginal }[S.fit]).classList.add('active');
        localStorage.setItem('fit', S.fit);

        if (S.mode === 'vertical') {
          // Vertical is naturally fit-width; we keep user pinch (browser) if they use it.
          el.strip.style.maxWidth = '1200px';
        } else {
          S.scale = 1; S.panX = 0; S.panY = 0;
          transformPage();
        }
      }

      function getBaseScale() {
        const img = el.page;
        const wrapW = el.pageWrap.clientWidth;
        const wrapH = el.pageWrap.clientHeight;
        const iw = img.naturalWidth || img.width || 1;
        const ih = img.naturalHeight || img.height || 1;

        if (S.fit === 'width')  return wrapW / iw;
        if (S.fit === 'height') return wrapH / ih;
        return 1; // original
      }

      function transformPage() {
        if (S.mode !== 'paged') return;
        const base = getBaseScale();
        const scale = base * S.scale;
        el.page.style.transform = `translate(${S.panX}px, ${S.panY}px) scale(${scale})`;
      }

      function zoom(delta) {
        S.scale = clamp(S.scale + delta, S.minScale, S.maxScale);
        transformPage();
      }
      function zoomReset() { S.scale = 1; S.panX = 0; S.panY = 0; transformPage(); }

      // ===== Mode & Direction =====
      function applyMode() {
        [el.modePaged, el.modeVertical].forEach(b => b.classList.remove('active'));
        if (S.mode === 'vertical') {
          el.modeVertical.classList.add('active');
          el.pageWrap.hidden = true;
          el.webtoon.hidden = false;
          el.thumbs.style.display = 'flex';
        } else {
          el.modePaged.classList.add('active');
          el.pageWrap.hidden = false;
          el.webtoon.hidden = true;
          el.thumbs.style.display = 'flex';
        }
        localStorage.setItem('mode', S.mode);
        applyFit();
        if (S.mode === 'paged') showPage(S.pageIndex);
      }

      function applyDir() {
        [el.dirLTR, el.dirRTL].forEach(b => b.classList.remove('active'));
        ({ ltr: el.dirLTR, rtl: el.dirRTL }[S.dir]).classList.add('active');
        localStorage.setItem('dir', S.dir);
      }

      // ===== Fullscreen =====
      function toggleFS() {
        if (!document.fullscreenElement) document.documentElement.requestFullscreen?.();
        else document.exitFullscreen?.();
      }

      // ===== UI Auto-hide =====
      function showUI() {
        el.reader.classList.add('show-ui');
        clearTimeout(S.uiTimer);
        S.uiTimer = setTimeout(() => el.reader.classList.remove('show-ui'), 1800);
      }

      // ===== Gestures & Input =====
      // Touch: swipe next/prev in paged mode, double-tap zoom
      let touchStartX = 0, touchStartY = 0, lastTap = 0;
      el.stage.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          touchStartX = e.touches[0].clientX;
          touchStartY = e.touches[0].clientY;
          const now = Date.now();
          if (now - lastTap < 300) { // double tap
            if (S.mode === 'paged') zoom( S.scale < 1.5 ? +0.5 : -0.5 );
          }
          lastTap = now;
        }
      }, {passive: true});
      el.stage.addEventListener('touchend', (e) => {
        if (e.changedTouches.length === 1) {
          const dx = e.changedTouches[0].clientX - touchStartX;
          const dy = e.changedTouches[0].clientY - touchStartY;
          const absX = Math.abs(dx), absY = Math.abs(dy);
          if (absX > 60 && absX > absY && S.mode === 'paged') {
            (dx < 0) ? next() : prev();
          }
        }
      });

      // Desktop: double-click zoom in paged mode
      el.stage.addEventListener('dblclick', () => {
        if (S.mode === 'paged') zoom(S.scale < 1.5 ? +0.5 : -0.5);
      });

      // Mouse wheel zoom (Ctrl+wheel) in paged mode
      el.stage.addEventListener('wheel', (e) => {
        if (e.ctrlKey && S.mode === 'paged') {
          e.preventDefault();
          zoom(e.deltaY < 0 ? +0.1 : -0.1);
        }
      }, { passive: false });

      // Basic pan while zoomed (paged)
      el.pageWrap.addEventListener('pointerdown', (e) => {
        if (S.mode !== 'paged') return;
        const base = getBaseScale();
        if (S.scale * base <= 1.01) return; // no pan if not zoomed beyond fit
        S.dragging = true;
        el.pageWrap.setPointerCapture(e.pointerId);
        S.dragStart = { x: e.clientX, y: e.clientY, panX: S.panX, panY: S.panY };
      });
      el.pageWrap.addEventListener('pointermove', (e) => {
        if (!S.dragging) return;
        const dx = e.clientX - S.dragStart.x;
        const dy = e.clientY - S.dragStart.y;
        S.panX = S.dragStart.panX + dx;
        S.panY = S.dragStart.panY + dy;
        transformPage();
      });
      const endPan = (e) => { S.dragging = false; try { el.pageWrap.releasePointerCapture(e.pointerId); } catch {} };
      el.pageWrap.addEventListener('pointerup', endPan);
      el.pageWrap.addEventListener('pointercancel', endPan);
      el.pageWrap.addEventListener('pointerleave', endPan);

      // Keyboard shortcuts
      window.addEventListener('keydown', (e) => {
        const k = e.key.toLowerCase();

        // Navigation
        if (['arrowright', 'd', 'l'].includes(k)) { next(); showUI(); return; }
        if (['arrowleft', 'a', 'h'].includes(k))  { prev(); showUI(); return; }

        // Zoom
        if (k === '+') { zoom(+0.1); showUI(); return; }
        if (k === '-' || k === '_') { zoom(-0.1); showUI(); return; }
        if (k === '0') { zoomReset(); showUI(); return; }

        // Mode toggle
        if (k === 'v') { S.mode = (S.mode === 'vertical') ? 'paged' : 'vertical'; applyMode(); showUI(); return; }

        // Fullscreen
        if (k === 'f') { toggleFS(); showUI(); return; }

        // Space/PageUp/PageDown for vertical scroll like webtoon
        if (S.mode === 'vertical') {
          if (k === ' ') { e.preventDefault(); el.webtoon.scrollBy({ top: el.webtoon.clientHeight * 0.9, behavior: 'smooth' }); showUI(); return; }
          if (k === 'pageup')   { e.preventDefault(); el.webtoon.scrollBy({ top: -el.webtoon.clientHeight * 0.9, behavior: 'smooth' }); showUI(); return; }
          if (k === 'pagedown') { e.preventDefault(); el.webtoon.scrollBy({ top:  el.webtoon.clientHeight * 0.9, behavior: 'smooth' }); showUI(); return; }
        }
      });

      // Buttons
      el.btnPrev.onclick = () => { prev(); showUI(); };
      el.btnNext.onclick = () => { next(); showUI(); };
      el.modePaged.onclick = () => { S.mode = 'paged'; applyMode(); showUI(); };
      el.modeVertical.onclick = () => { S.mode = 'vertical'; applyMode(); showUI(); };
      el.dirLTR.onclick = () => { S.dir = 'ltr'; applyDir(); showUI(); };
      el.dirRTL.onclick = () => { S.dir = 'rtl'; applyDir(); showUI(); };
      el.fitWidth.onclick = () => { S.fit = 'width'; applyFit(); showUI(); };
      el.fitHeight.onclick = () => { S.fit = 'height'; applyFit(); showUI(); };
      el.fitOriginal.onclick = () => { S.fit = 'original'; applyFit(); showUI(); };
      el.zoomIn.onclick = () => { zoom(+0.1); showUI(); };
      el.zoomOut.onclick = () => { zoom(-0.1); showUI(); };
      el.zoomReset.onclick = () => { zoomReset(); showUI(); };
      el.themeLight.onclick = () => applyTheme('light');
      el.themeSystem.onclick = () => applyTheme('system');
      el.themeDark.onclick = () => applyTheme('dark');
      el.btnFS.onclick = toggleFS;

      // Pointer movement shows UI briefly (auto-hide after)
      ['pointermove', 'mousemove', 'touchmove'].forEach(evt => {
        el.stage.addEventListener(evt, () => showUI(), { passive: true });
      });

      // Click on stage toggles UI quickly
      el.stage.addEventListener('click', (e) => {
        if (e.target.closest('.btn') || e.target.closest('.thumbs')) return;
        el.reader.classList.toggle('show-ui');
        if (el.reader.classList.contains('show-ui')) showUI();
      });

      // ===== Init =====
      (function init() {
        applyTheme(S.theme);
        applyDir();
        buildThumbs();
        buildStrip();
        applyMode();
        if (S.mode === 'paged') showPage(S.pageIndex);
        showUI();
        // Re-transform on resize
        new ResizeObserver(() => transformPage()).observe(el.pageWrap);
      })();
    })();
  </script>
</body>
</html>
